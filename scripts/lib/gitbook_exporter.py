from pathlib import Path
from lib.base import BaseExporter
import os
import re
import shutil

class GitbookExporter(BaseExporter):
    def __init__(self, 
                 techniques_path, findings_path, playbooks_path,
                 fti_playbooks, fti_techiques, fti_findings
                 ):
        super(GitbookExporter, self).__init__(
            techniques_path, findings_path, playbooks_path,
            fti_playbooks, fti_techiques, fti_findings
            )

    @staticmethod
    def convert_to_name(s):
        #standardize filenames: changes anything except words and - to undescore_
        #doesn't allow to use slashes /\
        return re.sub(r'[^\w\-]+', '_', s).lower()

    @staticmethod
    def convert_to_path(s):
        #standardize filepaths: changes anything except words, - and slashes to undescore_
        #allows to use slashes /\
        return re.sub(r'[^\w\-\\/]+', '_', s).lower()

    @staticmethod
    def add_to_tree(tree, path, title, id):
        for part in path:
            if part not in tree:
                tree[part] = {}
            tree = tree[part]
        if 'items' not in tree:
            tree['items'] = []
        tree['items'].append((title, id))

    @staticmethod
    def print_tree(tree, prefix='techniques', depth=0):
        tree_str = ""
        for k, v in tree.items():
            if k == 'items':
                for item, id in v:
                    tree_str += '  ' * depth + f"* [{item}]({prefix}/{GitbookExporter.convert_to_path(id)}.md)\n"
            else:
                tree_str += '  ' * depth + f"* [{k}]({prefix}/{GitbookExporter.convert_to_path(k)}/)\n"
                tree_str += GitbookExporter.print_tree(v, f"{prefix}/{GitbookExporter.convert_to_path(k)}", depth + 1)
        return tree_str

    @staticmethod
    def extract_categories(categories, title, id, tree, path=[]):
        if isinstance(categories, list):
            for category in categories:
                GitbookExporter.extract_categories(category, title, id, tree, path)
        elif isinstance(categories, dict):
            for k, v in categories.items():
                GitbookExporter.extract_categories(v, title, id,  tree, path + [k])
        elif isinstance(categories, str):
            GitbookExporter.add_to_tree(tree, path + [categories], title, id)
    
    def export(self, export_directory_path):
        techniques_tree= self.export_techniques(directory_path=export_directory_path)
        playbooks_tree = self.export_playbooks(directory_path=export_directory_path)
        findings_tree = self.export_findings(directory_path=export_directory_path)

        summary = '# Table of contents\n'
        summary += '* [ðŸ‘‹ Welcome!](README.md)\n\n'

        summary += '* [ðŸ‘‹ Techniques](techniques)\n'
        techniques_tree_modified = '\n'.join(["  " + s for s in techniques_tree.split('\n')])
        summary += techniques_tree_modified

        summary += '\n* [ðŸ‘‹ Playbooks](playbooks)\n'
        playbooks_tree_modified = '\n'.join(["  " + s for s in playbooks_tree.split('\n')])
        summary += playbooks_tree_modified

        summary += '\n* [ðŸ‘‹ Findings](findings)\n'
        summary += findings_tree

        summary_path = os.path.join(export_directory_path,'SUMMARY.md')
        with open(summary_path,"w") as f:
            f.write(summary)

    def export_techniques(self, directory_path):
        export_dir = os.path.join(directory_path, 'techniques')

        #remove the dir if already exist
        shutil.rmtree(export_dir, ignore_errors=True)
        
        for technique_id, technique in self.techniques.items():
            print (technique_id)
            flatten_categories = self.flatten_categories(technique['category'], delimiter='/')

            md_technique = self.convert_technique(technique_id=technique_id, fields_to_include=self.fti_techiques)
            md_technique = f"# {technique['title']}\n\n" + md_technique

            for category in flatten_categories:

                category = GitbookExporter.convert_to_path(category)
                filename = GitbookExporter.convert_to_path(technique['id'])

                export_path_md = os.path.join(export_dir, category, filename + ".md")

                techique_files_path = os.path.join(export_dir, category, filename)

                shutil.copytree(os.path.dirname(technique['filepath']), techique_files_path)
                os.remove(os.path.join(techique_files_path,filename+ ".yml"))
                
                if not os.path.exists(techique_files_path):
                    os.makedirs(techique_files_path)

                with open(export_path_md, 'w') as f:
                    f.write(md_technique)
        
        #make techqniques summary
        all_techiques = [self.techniques[k] for k in self.techniques.keys()]
        category_tree = {}
        for item in all_techiques:
            GitbookExporter.extract_categories(item['category'], item['title'], item['id'], category_tree)
        techniques_tree = GitbookExporter.print_tree(category_tree)

        return techniques_tree

    def export_findings(self, directory_path):
        export_dir = os.path.join(directory_path, 'findings')

        #remove the dir if already exist
        shutil.rmtree(export_dir, ignore_errors=True)
        
        for finding_id, finding in self.findings.items():

            md_finding = self.convert_finding(finding_id=finding_id, fields_to_include=self.fti_findings)
            md_finding = f"# {finding['title']}\n\n" + md_finding
            
            filename = GitbookExporter.convert_to_path(finding['id'])
            export_path_md = os.path.join(export_dir, filename + ".md")

            if not os.path.exists(export_dir):
                os.makedirs(export_dir)

            with open(export_path_md, 'w') as f:
                f.write(md_finding)
        
        #make finsings summary
        all_findings = [self.findings[k] for k in self.findings.keys()]
        category_tree = ''

        for item in all_findings:
            category_tree += f"  * [{item['title']}](findings/{GitbookExporter.convert_to_path(item['id'])}.md)\n"

        return category_tree

    def export_playbooks(self, directory_path):
        playbooks_tree = ''

        export_dir = os.path.join(directory_path, 'playbooks')

        for playbook_id, playbook in self.playbooks.items():
            category=self.convert_to_name(playbook['category'])

            playbook_export_dir = os.path.join(export_dir, category)
            if not os.path.exists(playbook_export_dir):
                os.makedirs(playbook_export_dir)
            
            playbooks_tree += f"* [{playbook['category']}](playbooks/{category}/)\n"
            
            block_counter = 1
            for block in playbook['blocks']:

                #we should create an md file with the block name here
                block_dir_name = self.convert_to_name(f"{block_counter}_" + block['name'])
                block_export_dir = os.path.join(playbook_export_dir, block_dir_name)
                if not os.path.exists(block_export_dir):
                    os.makedirs(block_export_dir)
                
                playbooks_tree += f"  * [{block_counter}. {block['name']}](playbooks/{category}/{block_dir_name}/)\n"
                
                test_counter = 1
                for current_test in block['tests']:
                    tests_md = ''
                    test_filename = self.convert_to_name(f"{block_counter}.{test_counter}_" + current_test['name'])
                    test_export_path = os.path.join(block_export_dir, test_filename + '.md')

                    playbooks_tree += f"    * [{block_counter}.{test_counter} {current_test['name']}](playbooks/{category}/{block_dir_name}/{test_filename+ '.md'})\n"

                    if 'techniques' in current_test and current_test['techniques']:

                        for current_techique in current_test['techniques']:
                            
                            technique_counter = 0.1

                            technique_id = current_techique['id']
                            techique = self.techniques[technique_id]

                            technique_md = self.convert_technique(
                                technique_id=technique_id,
                                index=test_counter+technique_counter,
                                fields_to_include=self.fti_techiques
                            )
                            tests_md += technique_md

                            #create a directory for each technique to host images or any related files there
                            filename = GitbookExporter.convert_to_path(techique['id'])
                            files_dir = os.path.join(block_export_dir, filename)
                            shutil.rmtree(files_dir, ignore_errors=True)
                            shutil.copytree(os.path.dirname(techique['filepath']), files_dir)
                            filename = GitbookExporter.convert_to_path(techique['id'])
                            os.remove(os.path.join(files_dir, filename+ ".yml"))

                            technique_counter += 1


                    #add information about possible findings
                    if 'findings' in current_test and current_test['findings']:
                        tests_md += '# Possible Findings:\n'

                        for current_finding in current_test['findings']:
                            finding = self.findings[current_finding['id']]
                            finding_name = GitbookExporter.convert_to_name(finding['id'])
                            tests_md += f"* [{finding['title']}](../../../findings/{finding_name}.md)\n"

                    with open(test_export_path,'w') as f:
                        f.write(tests_md)
                    
                    test_counter += 1

                block_counter += 1

        return playbooks_tree

    def convert_technique(self, technique_id, fields_to_include, index=1):
        t = self.techniques[technique_id]

        md = f""
        if not t:
            return ""

        # Title
        if 'id' in fields_to_include and 'title' in fields_to_include:
            md += f"## {t['title']} [{technique_id}]\n\n"
        elif 'id' in fields_to_include:
            md += f"## [{technique_id}]\n\n"
        elif 'title' in fields_to_include:
            md += f"## {t['title']} \n\n"

        # Description
        if 'description' in fields_to_include:
            
            #old style yaml
            if type(t['description']) is str:
                md += f"{t['description']}\n\n"

            #new style yaml
            elif type(t['description']) is list:
                for description_part in t['description']:
                    if 'title' in description_part and description_part['title']:
                        md += f"### {description_part['title']}\n\n"
                    md += f"{description_part['content']}\n\n"

                    if 'references' in description_part and len(description_part['references']) > 0:
                        images = [f for f in description_part['references'] if f['type']=='image']
                        for image in images:
                            image_path = os.path.join(self.convert_to_name(t['id']),image['value'])
                            if 'comment' in image and image['comment']:
                                img_desc = image['comment']
                            else:
                                img_desc = image['value']

                            md += f"![{img_desc}]({image_path})\n"
                        
                        links = [f for f in description_part['references'] if f['type']=='link']
                        if len(links) > 0:
                            md += f"\n### References:\n\n"
                            for link in links:
                                md += f"* [{link['value']}]({link['value']})\n\n"

        # Comments
        if 'comments' in fields_to_include and 'comments' in t and t['comments']:

            #md += f"### Comments:\n\n```"
            md += '\n{% hint style="info" %}'
            if type(t['comments']) is list:
                for comment in t['comments']:
                    md += f"{comment}\n"
            else:
                md += f"{t['comments']}\n"
            #md += '\n```\n\n'
            md += '{% endhint %}\n'

        # Steps
        if 'steps' in fields_to_include and 'steps' in t and t['steps']:
            subsub_index = 1

            for current_step in t['steps']:

                if len(t['steps']) > 1:
                    new_index = str(index) + '.' + str(subsub_index)
                else:
                    new_index = ""

                md += f"### {new_index} "

                if 'title' in current_step:
                    md += f"{current_step['title']}\n\n"
                elif 'description' in current_step:
                    md += f"{current_step['description']}\n\n"

                md += "\n\n"

                if 'options' in current_step and current_step['options']:

                    option_index = 1
                    for current_option in current_step['options']:
                        if not current_option:
                            continue
                        
                        if len(current_step['options']) > 1:
                            md += f"\n**option {option_index}: {current_option['tool']}**\n\n"

                        if 'usage' in current_option and current_option['usage']:
                            md += '{% code overflow="wrap" %}\n' + f"```bash\n{current_option['usage']}\n```\n" + '{% endcode %}\n\n'

                        if 'comments' in current_option and current_option['comments']:
                            md += '{% hint style="info" %}'
                            if type(current_option['comments']) is list and len(current_option['comments']) > 0:
                                for comment in current_option['comments']:
                                    md += f"{comment}\n\n"
                            else:
                                md += f"{current_option['comments']}\n\n"

                            md += '{% endhint %}\n\n'
                        
                        if 'references' in current_option and len(current_option['references']) > 0:
                            images = [f for f in current_option['references'] if f['type']=='image']
                            for image in images:
                                image_path = os.path.join(self.convert_to_name(t['id']), image['value'])
                                if 'comment' in image and image['comment']:
                                    img_desc = image['comment']
                                else:
                                    img_desc = image['value']

                                md += f"![{img_desc}]({image_path})\n"
                        
                            links = [f for f in current_option['references'] if f['type']=='link']
                            if len(links) > 0:
                                md += f"\n### References:\n\n"
                                for link in links:
                                    md += f"* [{link['value']}]({link['value']})\n\n"

                        option_index += 1
                subsub_index +=1

        return md

    def convert_finding(self, finding_id, fields_to_include):
        f = self.findings[finding_id]

        md = ''

        if not f:
            md += f"## [{finding_id}]\n\n"
            return md

        if 'id' in fields_to_include and 'title' in fields_to_include:
            md += f"## {f['title']} [{finding_id}]\n\n"
        elif 'id' in fields_to_include:
            md += f"## [{finding_id}]\n\n"
        elif 'title' in fields_to_include:
            md += f"## {f['title']} \n\n"

        if 'description' in fields_to_include:
            md += f"**Description:**\n\n{f['description']}\n\n"

        if 'risk' in fields_to_include:
            md += f"**Risk:**\n\n{f['risk']}\n\n"

        if 'mitigations' in fields_to_include:
            md += f"**Mitigations:**\n\n"

            for mitigation in f['mitigations']:
                md += f"{mitigation}\n\n"

        if 'references' in fields_to_include:
            if 'references' in f and f['references']:
                md += f"**References:**\n\n"
                for reference in f['references']:
                    md += f"* {reference}\n\n"

        if 'evidences' in fields_to_include:
            md += f"**Evidences:**\n\n"
            for evidence in f['evidences']:
                md += f"* {evidence}\n\n"

        return md
